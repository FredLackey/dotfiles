#!/bin/bash

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Clone a repository and install its dependencies.

clone() {

    git clone "$1" \
        || return

    cd "$(basename "${1%.*}")" \
        || return

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    # Check if there are dependencies to be installed.

    if [ ! -f "package.json" ]; then
        return
    fi

    # Check if the project uses Yarn.

    if [ -f "yarn.lock" ] && command -v "yarn" $> /dev/null; then
        printf "\n"
        yarn install
        return
    fi

    # If not, assume it uses npm.

    if command -v "npm" $> /dev/null; then
        printf "\n"
        npm install
    fi

}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Create data URI from a file.

datauri() {

    local mimeType=""

    if [ ! -f "$1" ]; then
        printf "%s is not a file.\n" "$1"
        return
    fi

    mimeType=$(file --brief --mime-type "$1")
    #               └─ do not prepend the filename to the output

    if [[ $mimeType == text/* ]]; then
        mimeType="$mimeType;charset=utf-8"
    fi

    printf "data:%s;base64,%s" \
        "$mimeType" \
        "$(openssl base64 -in "$1" | tr -d "\n")"

}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Delete files that match a certain pattern from the current directory.

delete-files() {
    local q="${1:-*.DS_Store}"
    find . -type f -name "$q" -ls -delete
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Execute Vim macro

evm() {

    local numberOfTimes="${*: -1}"
    local files

    if [[ "$numberOfTimes" =~ ^[0-9]+$ ]]; then
        files=("${@:1:$#-1}")
    else
        numberOfTimes="1"
        files=("$@")
    fi

    for file in "${files[@]}"; do
        printf "* %s\n" "$file"
        vim \
            -c "norm! $numberOfTimes@q" \
            -c "wq" \
            "$file"
    done

}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Search history.

h() {
    #           ┌─ Enable colors for pipe.
    #           │  ("--color=auto" enables colors only
    #           │   if the output is in the terminal.)
    grep --color=always "$*" "$HISTFILE" \
        | less --no-init --raw-control-chars
          #    │         └─ Display ANSI color escape sequences in raw form.
          #    └─ Don't clear the screen after quitting less.
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# From the specified files, rename the files containing a date
# in the filename to only the date in the following format:
#
#    <year>-<month>-<day> <hour>.<minute>.<second>
#
# Usage examples:
#
#  * rename-files-with-date-in-name path/to/some/directory path/to/some/file ...

rename-files-with-date-in-name() (

    rename_file() (
        filePath=$(dirname "${1%/}")
        fileName=$(basename "$1")

        # The following will do transformations such as:
        #
        #   * 20200505_050505.dng => 2020-05-05 05.05.05.dng
        #   * Screenshot 2020-01-02 at 03.04.05.png => 2020-01-02 03-04-05.jpg
        #   * Screenshot_20201010-101010_Something.jpg => 2020-10-10 10-10-10.jpg
        #   * signal-2020-05-06-07-08-09-123.mp4 => 2020-05-06 07-08-09.mp4

        newFilePath="${filePath}/$(printf "%s" "$fileName" | sed 's/[^0-9]*\([0-9]\{4\}\)[_-]\{0,1\}\([0-9]\{2\}\)[_-]\{0,1\}\([0-9]\{2\}\)[_-]\{0,1\}\( at \)\{0,1\}\([0-9]\{2\}\)[_.-]\{0,1\}\([0-9]\{2\}\)[_.-]\{0,1\}\([0-9]\{2\}\).*\(\..*\)$/\1-\2-\3 \5.\6.\7\8/')"

        if [ "$newFilePath" != "$1" ]; then
           mv -f "$1" "$newFilePath"
        fi
    )

    #                 ┌─ Default to the current directory.
    for filePath in "${@:-.}"; do
        if [ -d "$filePath" ]; then
            find "${filePath%/}" \
                -type f \
                -depth 1 \
                -print \
            | while read -r f; do
                rename_file "$f"
            done
        elif [ -f "$filePath" ]; then
            rename_file "$filePath"
        fi
    done

)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Resize image.
#
# Create a new image based on the specified image resized by the
# specified amount.
#
# $1: Path to the original image.
# $2: Resize value (default is 50%).
#     See also: https://imagemagick.org/script/command-line-processing.php#geometry
#
# Usage examples:
#
#   * resize-image ./path/to/image.jpg 30%
#   * resize-image ./path/to/image.jpg 1000x1000!

resize-image() {

    # Check if ImageMagick's convert command-line tool is installed.

    if ! command -v "convert" $> /dev/null; then
        printf "ImageMagick's 'convert' command-line tool is not installed!"
        exit
    fi

    # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    declare path="$(dirname "$1")"
    declare fileName="$(basename "$1")"
    declare geometry="${2:-50%}"

    convert \
        "$1" \
        -colorspace RGB \
        +sigmoidal-contrast 11.6933 \
        -define filter:filter=Sinc \
        -define filter:window=Jinc \
        -define filter:lobes=3 \
        -sigmoidal-contrast 11.6933 \
        -colorspace sRGB \
        -background transparent \
        -gravity center \
        -resize "$geometry" \
        +append \
        "$path/_$fileName" \
    && printf "* %s (%s)\n" \
            "$path/_$fileName" \
            "$geometry"

}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Search for text within the current directory.

s() {
    grep --color=always "$*" \
         --exclude-dir=".git" \
         --exclude-dir="node_modules" \
         --ignore-case \
         --recursive \
         . \
        | less --no-init --raw-control-chars
          #    │         └─ Display ANSI color escape sequences in raw form.
          #    └─ Don't clear the screen after quitting less.
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Cutomizations

# Delete files that match a certain pattern from the current directory.
clean-dev() {
    sudo find . -name "node_modules" -exec rm -rf '{}' +
    find . -name "bower_components" -exec rm -rf '{}' +
}

# Kill off Node Inspector
killni() {
    killni_target='node --debug-brk'
    ps -ef | grep "$killni_target" | grep -v grep | awk '{print $2}' | xargs kill -9
}

# Push the Node project while using the version for the commit message.
vpush() {

    # Ensure JQ is installed
    if ! cmd_exists "jq"; then
        printf "jq is required, please install it!\n"
        exit 1
    fi

    pkg_ver=$(jq '.version' package.json)
    pkg_ver=${pkg_ver//\"/}
    git add -A
    git commit -a -S -m $pkg_ver
    git push origin master

}

set-git-public(){
    git config user.email "fred.lackey@gmail.com"
    git config user.name "Fred Lackey"
}

backup-source(){
    backupdir="$*$(date +"%Y%m%d%H%M%S")/"
    backupcmd="rsync -arv --progress --no-links --exclude={.Trash,.android,.atom,.bash_sessions,.cache,.cups,.dropbox,.git,.next,.npm,.nvm,.viminfo,bower_components,node_modules,.tmp,.idea,.DS_Store} ~/Source $backupdir"
    mkdir -p "$backupdir"
    eval "$backupcmd"
    cd "$backupdir"
}

backup-all(){

    excludes=".android,.atom,.bash_sessions,bower_components,.cache,.cups,.dropbox,.DS_Store,.git,_gsdata_,.idea,node_modules,.next,.npm,.nvm,\$RECYCLE.BIN,System\ Volume\ Information,.TemporaryItems,.Trash,.Trashes,.tmp,.viminfo"

    backupdir="$*"
    backupcmd="rsync -arv --progress --no-links --exclude={$excludes} ~/Downloads $backupdir"
    eval "$backupcmd"

    backupdir="$*$(date +"%Y%m%d%H%M%S")/"
    backupcmd="rsync -arv --progress --no-links --exclude={$excludes} ~/Backups ~/Desktop ~/Documents ~/Microsoft ~/Movies ~/Music ~/Pictures ~/Public ~/Source ~/Templates ~/Temporary ~/Videos $backupdir"
    mkdir -p "$backupdir"
    eval "$backupcmd"

    cd "$backupdir"
    ls -la
}

org-by-date(){
    ls -A1 | grep -E '[0-9]{4}-[0-9]{2}-[0-9]{2}' | while read -r line; do
        DNAME="$(echo $line | grep -Eo '[[:digit:]]{4}-[[:digit:]]{2}-[[:digit:]]{2}' | sed 's#-#/#g')"
        mkdir -p "./$DNAME"
        mv "$line" "./$DNAME/"
    done
}

get-course(){
    local usage="get-course %COURSE_NAME_FROM_URL% %USERNAME% %PASSWORD%";
    local course="$1";
    local username="$2";
    local password="$3";
    local prefix="";
    if [ -e "/usr/local/bin/yt-dlp" ]; then
        prefix="/usr/local/bin/";
    fi
    if [ -z "$course" ]; then
      echo "Problem getting Pluralisight course: Course name not supplied"
      echo "$usage"
    elif [ -z "$username" ]; then
      echo "Problem getting Pluralisight course: Username not supplied"
      echo "$usage"
    elif [ -z "$password" ]; then
      echo "Problem getting Pluralisight course: Password not supplied"
      echo "$usage"
    else
      eval "${prefix}yt-dlp --verbose --username $username --password $password --rate-limit 50K --sleep-interval 600 -o \"%(autonumber)s - %(title)s.%(ext)s\" \"https://app.pluralsight.com/library/courses/${course}\""
    fi
}

get-channel(){
    local usage="get-channel %COURSE_NAME_FROM_URL%";
    local channel="$1";
    local prefix="";
    if [ -e "/usr/local/bin/yt-dlp" ]; then
        prefix="/usr/local/bin/";
    fi
    if [ -z "$channel" ]; then
      echo "Problem getting Youtube channel: Channel name not supplied"
      echo "$usage"
    else
      eval "${prefix}yt-dlp -f best -ciw -v -o \"%(upload_date)s - %(title)s.%(ext)s\" https://www.youtube.com/user/$channel"
    fi
}

get-tunes(){
    local usage="get-tunes %PLAYLIST_OR_VIDEO_URL% [audio-only | video-only]";
    local url="$1";
    local option="$2";
    local prefix="";
    if [ -f "/usr/local/bin/yt-dlp" ]; then
        prefix="/usr/local/bin/";
    fi
    if [ -z "${url}" ]; then
        echo "Problem fetching track: Track URL not supplied";
        echo "$usage";
    elif [ -z "${option}" ]; then
        echo "Fetching audio & video...";
        eval "${prefix}yt-dlp --buffer-size 16K --keep-video --audio-format mp3 --extract-audio --embed-thumbnail --prefer-insecure --format mp4 --ignore-errors --output '%(title)s.%(ext)s' $1";
    elif [[ "$option" == "audio-only" ]]; then
        echo "Excluding video...";
        eval "${prefix}yt-dlp --buffer-size 16K --audio-format mp3 --extract-audio --embed-thumbnail --prefer-insecure --ignore-errors --output '%(title)s.%(ext)s' $1";
    elif [[ "$option" == "video-only" ]]; then
        echo "Excluding audio...";
        eval "${prefix}yt-dlp --buffer-size 16K --keep-video --prefer-insecure --format mp4 --ignore-errors --output '%(title)s.%(ext)s' $1";
    else
        echo "Problem fetching track: Unknown option supplied ($option)";
        echo "$usage";
    fi
}

get-video(){
    local usage="get-tunes %VIDEO_URL%";
    local url="$1";
    if [ -f "/usr/local/bin/yt-dlp" ]; then
        prefix="/usr/local/bin/";
    fi
    if [ -z "${url}" ]; then
        echo "Problem fetching video: URL not supplied";
        echo "$usage";
    else
        echo "Excluding audio...";
        # Starting syntax from: https://www.jeffgeerling.com/blog/2022/how-download-mp4-youtube-every-time
        # yt-dlp -S res,ext:mp4:m4a --recode mp4
        # yt-dlp -S res,ext:mp4:m4a --recode mp4 --output '%(title)s.%(ext)s' $1
        # yt-dlp -S res,ext:mp4:m4a --recode mp4 --output '%(title)s.%(ext)s' https://youtu.be/SxwxO8ruabY
        eval "${prefix}yt-dlp --buffer-size 16K --keep-video --prefer-insecure --format mp4 --ignore-errors --output '%(title)s.%(ext)s' $1";
    fi
}

get-folder() {
    # Ensure source and target paths end with a forward slash
    source="${1%/}/"
    target="${2%/}/"

    # Check if rsync command exists
    if command -v rsync &> /dev/null; then
        # Use rsync if available
        for file in "$source"*; do
            filename=$(basename "$file")
            if [ -f "$target$filename" ]; then
                # Check if file size matches
                source_size=$(stat -c %s "$file")
                target_size=$(stat -c %s "$target$filename")
                if [ "$source_size" -eq "$target_size" ]; then
                    echo "Skipping $filename as it already exists and has the same size."
                else
                    rsync -avP "$file" "$target"
                fi
            else
                rsync -avP "$file" "$target"
            fi
        done
    # Check if robocopy command exists (assuming it's run from Git Bash on Windows)
    elif command -v robocopy &> /dev/null; then
        # Use robocopy equivalent syntax
        robocopy "$source" "$target" /E /Z /W:1 /R:3
    else
        echo "Error: Neither rsync nor robocopy command found."
        return 1
    fi
}

docker-clean(){
    # Delete all containers
    docker rm -f $(docker ps -a -q)
    # Delete all images
    docker images -q | xargs docker rmi -f
    # Delete volumes
    docker volume rm $(docker volume ls -q)
}

git-clone(){
    eval "rsync -av --progress $* ./ --exclude .git --exclude README.md --exclude LICENSE --exclude node_modules --exclude bower_components"
}

git-pup(){
    git pull && git submodule init && git submodule update && git submodule status
}

ips(){
    local usage="ips [%NETWORK_BASE_IP%] [%BIT_DEPTH%] [ip-only | no-sudo]"$'\n'"Default IP: 192.168.1.0"$'\n'"Default Mask: 24"
    local addr="$1";
    local mask="$2";
    local prefix="";
    local suffix="";

    # Ensure nmap is installed
    if ! cmd_exists "nmap"; then
        printf "nmap is required, please install it!\n"
        exit 1
    fi

    # display help if needed
    if [[ "$@" =~ "help" ]]; then
      echo "$usage";
      return 0;
    fi

    # filter out details if only ips are needed
    if [[ "$@" =~ "ip-only" ]]; then
      suffix=" | grep report | awk '{print \$5}'";
    fi

    # remove sudo if is to be run without it
    if [[ "$@" =~ "no-sudo" ]]; then
      prefix="";
    else
      prefix="sudo ";
    fi

    # ensure the subnet mask is between 4 and 32 bits (default to 24)
    if [[ "$mask" =~ ^[0-9]+$ ]] && [ "$mask" -ge 4 -a "$mask" -le 30 ]; then
      mask="$mask";
    else
      echo "Invalid mask supplied.  Defaulting to 24 bits."
      mask="24";
    fi

    # proceed if the first value is a valid IP address
    if [[ ! $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
      echo "Invalid IP address supplied.  Defaulting to 192.168.1.0."
      addr="192.168.1.0";
    fi

    eval "${prefix}nmap $addr/$mask -n -sP${suffix}"
}

refresh-files(){

    # Compares files in current project (the TARGET_FOLDER)
    # to files in a stable project (SOURCE_FOLDER) and copies
    # over local copies with stable version if both exist.
    # Useful for protecting critical files, such as vendor
    # source, sensitive data, etc.

    local usage="refresh-files SOURCE_FOLDER [TARGET_FOLDER]"
    local source="$1";
    local target="${2:-${PWD}}";
    local noise="$3";
    local err="";
    local relpath="";
    local from=""
    local counter=0;

    if [ -z "$source" ]; then
      err="Source folder not supplied.";
    elif [ ! -d "$source" ]; then
      err="Source folder does not exist.";
    elif [ ! -d "$target" ]; then
      echo "target: $target"
      err="Target folder does not exist: $target";
    elif [ ! -z "$noise" ]; then
      err="Extra noise supplied in command.";
    fi

    if [ "$err" != "" ]; then
      echo "Problem refreshing files: $err";
      echo ""
      echo "USAGE: $usage"
    else

      echo "Refreshing files...";
      echo "FROM: $source";
      echo "TO  : $target";
      echo "-----";

      for file in $(find "$target" -type f -not \( -path "*/node_modules/*" \) -not \( -path "*/bower_components/*" \)); do

        relpath=$(echo "$file" | sed "s@$target@@");
        from=${source%/}${relpath};

        if [ -f "$from"  ]; then
          echo "$relpath"
          eval "cp $from $file";
          counter=$((counter+1))
        fi

      done

      echo "-----";
      echo "Files refreshed: $counter";

    fi

}

ncu-update-all(){

  if ! cmd_exists "ncu"; then
      printf "ncu is required, please install it!\n"
      exit 1
  fi

  for file in $(find . -type f -name "package.json" -not \( -path "*/node_modules/*" \) -not \( -path "*/bower_components/*" \)); do

    if [ -f "$file"  ]; then
      eval "ncu -a -u --packageFile $file"
    fi

  done

  for file in $(find . -type f -name "bower.json" -not \( -path "*/node_modules/*" \) -not \( -path "*/bower_components/*" \)); do

    if [ -f "$file"  ]; then
      eval "ncu -a -u -m bower --packageFile $file"
    fi

  done
}

talk(){
    eval "xsel | festival --tts --pipe"
}

remove_smaller_files(){
    LEFT_DIR="$PWD"
    RIGHT_DIR="$*"
    echo "LEFT : $LEFT_DIR"
    echo "RIGHT: $RIGHT_DIR"
    files="$(find -L "$LEFT_DIR" -type f)"
    echo "$files" | while read file; do
        FILE_NAME=${file#$LEFT_DIR}
        LEFT_FILE="$file"
        RIGHT_FILE="$RIGHT_DIR""$FILE_NAME"
        #echo "----------"
        #echo "Left File : $LEFT_FILE"
        #echo "Right File: $RIGHT_FILE"
        if [ -f "$LEFT_FILE" ]; then
            if [ -f "$RIGHT_FILE" ]; then
                LEFT_SIZE=( $( ls -Lon "$LEFT_FILE" ) )
                LEFT_BYTES=${LEFT_SIZE[3]}
                RIGHT_SIZE=( $( ls -Lon "$RIGHT_FILE" ) )
                RIGHT_BYTES=${RIGHT_SIZE[3]}
                #echo "----------"
                #echo "LEFT_SIZE: $LEFT_SIZE"
                #echo "LEFT_BYTES: $LEFT_BYTES"
                #echo "RIGHT_SIZE: $RIGHT_SIZE"
                #echo "RIGHT_BYTES: $RIGHT_BYTES"
                if [ "$LEFT_BYTES" -gt "$RIGHT_BYTES" ]; then
                    echo "REMOVED: $RIGHT_FILE"
                    eval "rm \"$RIGHT_BYTES\""
                elif [ "$RIGHT_BYTES" -gt "$LEFT_BYTES" ]; then
                    echo "REMOVED: $LEFT_FILE"
                    eval "rm \"$LEFT_FILE\""
                else
                    echo "SKIPPED: $FILE_NAME (same size)"
                fi
            fi
        fi
    done
}

npmi() {
    if [ ! -f "$PWD/package.json" ]; then
        echo "Not an NPM package folder."
        return 1
    fi
    if [ -e "$PWD/node_modules" ]; then
        echo "Removing old node_modules folder..."
        eval "rm -rf $PWD/node_modules"
        if [ -e "$PWD/node_modules" ]; then
            echo "... failure!"
            return 1
        else
            echo "... done."
        fi
    fi
    echo "Setting Node v18 and installing..."

    export NVM_DIR=$HOME/.nvm;
    source $NVM_DIR/nvm.sh;

    eval "nvm use 18 && npm i"
    if [ -e "$PWD/node_modules" ]; then
        echo "... done."
    else
        echo "... failure!"
        return 1
    fi
}

get-dependencies() {
    local package_json_path="$1"
    local dependency_type_prefix="${2:-dependencies}"
    local dependency_type=""

    # Check if jq is installed
    if ! command -v jq &> /dev/null; then
        echo "Error: jq command is not installed. Please install jq and try again."
        return 1
    fi

    # Check if a path was provided
    if [[ -z "$package_json_path" ]]; then
        echo "Usage: extract_dependencies /path/to/package.json [dependency_type_prefix]"
        echo "Example: extract_dependencies /path/to/package.json dev"
        return 1
    fi

    # Check if the package.json file exists
    if [[ ! -f "$package_json_path" ]]; then
        echo "Error: File not found: $package_json_path"
        return 1
    fi

    # Determine the full dependency type based on the prefix if provided
    if [[ -z "$dependency_type_prefix" ]]; then
        dependency_type="dependencies"
    else
        case "$dependency_type_prefix" in
            dev)
                dependency_type="devDependencies"
                ;;
            peer)
                dependency_type="peerDependencies"
                ;;
            opt)
                dependency_type="optionalDependencies"
                ;;
            bundle)
                dependency_type="bundledDependencies"
                ;;
            dependencies)
                dependency_type="dependencies"
                ;;
            *)
                echo "Error: Invalid dependency type prefix. Valid prefixes are: dev, peer, opt, bundle, dependencies."
                return 1
                ;;
        esac
    fi

    # Check if the dependency type node exists and is not null
    node_exists=$(jq -e --arg depType "$dependency_type" '.[$depType] != null' "$package_json_path")
    if [[ $? -ne 0 || "$node_exists" != "true" ]]; then
        return 0
    fi

    # Extract dependencies using jq
    dependencies=$(jq -r --arg depType "$dependency_type" '.[$depType] | keys[]?' "$package_json_path")
    if [[ -z "$dependencies" ]]; then
        return 0
    fi

    echo "$dependencies"
}

install-dependencies-from() {
    local package_json_path="$1"
    local dependency_type_prefix="${2:-dependencies}"
    local dependencies
    local npm_flag=""

    # Determine the npm flag based on the dependency type
    case "$dependency_type_prefix" in
        dev)
            npm_flag="--save-dev"
            ;;
        peer)
            npm_flag="--save-peer"
            ;;
        opt)
            npm_flag="--save-optional"
            ;;
        bundle)
            npm_flag="--save-bundled"
            ;;
        dependencies)
            npm_flag="--save"
            ;;
        *)
            echo "Error: Invalid dependency type prefix. Valid prefixes are: dev, peer, opt, bundle, dependencies."
            return 1
            ;;
    esac

    # Extract dependencies
    dependencies=$(get-dependencies "$package_json_path" "$dependency_type_prefix")

    if [[ -z "$dependencies" ]]; then
        echo "No dependencies to install."
        return 0
    fi

    # Install each dependency
    for dependency in $dependencies; do
        echo "Installing $dependency..."
        npm install "$dependency@latest" $npm_flag
    done
}
